= Horo - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103T-F12-1/main

By: `Team AY1920S1-CS2103T-F12-1`      Since: `Sept 2019`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Main structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/blob/master/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is contains 3 main view parts - `CalendarPanel`, `ListPanel`, `LogPanel`. It also holds several other UI parts e.g. `PopUpPanel` and `Command Box`. Every one of the UI classes will abstract from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework, and layout of these UI parts are defined in `.fxml` files which are found in the `src/main/resources/view` folder. One example of the layout would be: link:{repoURL}/blob/master/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`], whose FXML link is specified in link:{repoURL}/blob/master/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]




The `UI` component does the following:

* Executes user two different types commands using the `Logic` component.
** One command, when executed, affect the actual Events.
** The other command is executed to change the view of the UI. There are currently 3 main views in the application: `CalendarPanel`, `ListPanel`, `LogPanel`.
* It listens for any changes in the list of events using a listener:  link:{repoURL}/blob/master/src/main/java/seedu/address/model/listeners/EventListListener.java[`EventListListener`].
* It also listens for the output to the user with another listener: link:{repoURL}/blob/master/src/main/java/seedu/address/ui/listeners/UserOutputListener.java[`UserOutputListener`].

==== Calendar UI View

.Structure of the Calendar UI View
image::UiCalendarClassDiagram.png[]

The Calendar View is made up of the link:{repoURL}/blob/master/src/main/java/seedu/address/ui/panel/calendar/CalendarPanel.java[`CalendarPanel`], which holds several different other UI parts linked together to form the overall UI. In the Calendar View, it displays two UI parts of the Calendar: `CalendarScreen` and `TimelineView`.

link:{repoURL}/blob/master/src/main/java/seedu/address/ui/panel/calendar/CalendarScreen.java[`CalendarScreen`] is the screen which displays the calendar of a certain month and year to the user. It contains 6 x 7 instance of `CalendarGridDay`, which displays the days of the month.

link:{repoURL}/blob/master/src/main/java/seedu/address/ui/panel/calendar/TimelineView.java[`TimelineView`] is the screen which displays the timeline using 3 different classes which abstract from `TimelineView`.

* link:{repoURL}/blob/master/src/main/java/seedu/address/ui/panel/calendar/TimelineDayView.java[`TimelineDayView`] displays the timeline of a particular day in a certain month and year.
* link:{repoURL}/blob/master/src/main/java/seedu/address/ui/panel/calendar/TimelineWeekView.java[`TimelineWeekView`] displays the timeline of a particular week. The week is according to the `CalendarScreen`, where each row represents a week of a month.
* link:{repoURL}/blob/master/src/main/java/seedu/address/ui/panel/calendar/TimelineMonthView.java[`TimelineMonthView`] displays the timeline of a particular month in a certain year.

Each of these timeline will hold up to a certain amount of `CardHolder` depending on the type of `TimelineView`. Each of these `CardHolder` will then hold an amount of EventCards for displaying the event name and date.

==== List UI View

.Structure of the List UI View
image::UiListClassDiagram.png[]

The List View is made up of the link:{repoURL}/blob/master/src/main/java/seedu/address/ui/panel/list/ListPanel.java[`ListPanel`] which contains two lists views, `EventListView` and `TaskListView`

* link:{repoURL}/blob/master/src/main/java/seedu/address/ui/panel/list/EventListView.java[`EventListView`] displays the list of Events containing every piece of information of the Events.

* link:{repoURL}/blob/master/src/main/java/seedu/address/ui/panel/list/TaskListView.java[`TaskListView`] displays the list of Task, containing every piece of information of each Task. [__To be implemented__]

Similar to `TimelineView`, `EventListView` and `TaskListView` will contain a list of `Card`, but it will not be held in the `CardHolder`.

==== Log UI View

.Structure of the Log UI View
image::UiLogClassDiagram.png[]

The Log View is made up of the link:{repoURL}/blob/master/src/main/java/seedu/address/ui/panel/log/LogPanel.java[`LogPanel`] which contains several instances of `LogBox`.

link:{repoURL}/blob/master/src/main/java/seedu/address/ui/panel/log/LogBox.java[`LogBox`] displays literal information back to the user when it is called by `MainWindow` when it listens for a command.

[[Design-Logic]]
=== CommandManager component

==== Command

A `Command` is defined to be an immutable function, that can be invoked at any time, to perform any set of instructions. After executing the set of instructions, it will optionally return output to be displayed to the user.

In Horo, a `Command` implemented as an abstract class with an abstract `execute()` method. To create a new concrete command, extend from `Command` and implement `execute()`.

.Class diagram of Commands
image::CommandManager.png[]

If your concrete command requires any dependencies during execution, it is recommended to pass in the dependency from the constructor.

For example, if your command needs to be able to access `ModelManager`:
```
public class MyCommand extends Command {
	private final ModelManager model;
	MyCommand(ModelManager model) {
		this.model = model;
	}

	@Override
    CommandOutput execute() {
        this.model.doSomething();
		...
	}
}
```


==== CommandParser

A `CommandParser` is defined to be able to parse a `String` of user input, and return a `Command`.

In Horo, a `CommandParser` is implemented as a finite state machine (FSM). It parses user input token by token, and it transitions from state to state depending on the next token.

What the FSM is trying to do is tokenize user input into:

1. `Command keyword`
2. `Command phrase(s)`

A *command keyword* is defined as the first sequence of consecutive, non-whitespace characters of the user input. For the rest of this guide, a sequence of consecutive, non-whitespace characters will be referred to as a ‚Äòword‚Äô. A word can be described in the form of a regular expression (regex) as `[^\s]+`.

Examples of valid command keywords:

- `exit`
- `add_event`
- `123`
- `üò∫`

A *command phrase* is defined as either a word, or multiple words delimited by whitespace surrounded by quotes. Command phrases come after a command keyword.

Examples of valid command phrases:

- `Horse`
- `‚ÄùHomework‚Äù`
- `‚ÄùHoro‚Äôs Birthday‚Äù`
- `‚Äù24/10/2019 07:00‚Äù`
- `‚Äô24/10/2019 07:00‚Äô`
- `--description`

A valid command contains exactly one command keyword, and zero or more command phrases.

`[keyword] [phrase] [phrase] [phrase] ...`

.State diagram of CommandParser
image::CommandParser.png[]

After tokenizing, the command keyword is sent to a `CommandKeywordParser`, which returns a `CommandBuilder`. The remaining command phrases are sent to the `CommandBuilder`, which returns the `Command` we want.


==== CommandKeywordParser

A `CommandKeywordParser` is defined to be able to parse a command keyword, and return a `CommandBuilder`.

In Horo, a `CommandKeywordParser` uses a `HashMap` to map a command keyword to a `Supplier<CommandBuilder>`.


==== CommandBuilder

A `CommandBuilder` is defined to be able to accept an arbitrary amount of command settings, and eventually create a `Command` using those settings.

In Horo, a `CommandBuilder` is implemented such that the entire definition of a `Command` is in the `CommandBuilder`. The `CommandBuilder` will use those definitions to automagically parse command phrases.

The definition of a command is split into two parts:

1. `Command argument(s)`
2. `Command option(s)`

A *command option* is defined to have a keyword and a list of arguments.
An *option‚Äôs keyword* is defined to be a command phrase.
An *option‚Äôs argument* is defined to be a command phrase that is not an option‚Äôs keyword. An option‚Äôs argument is a command phrase that lies after the option‚Äôs keyword.

Example of option‚Äôs keyword & arguments below. The option‚Äôs keyword is underlined:

- `+++<u>--description</u>+++ Horse`
- `+++<u>--tags</u>+++ Animal Cat Dog`
- `+++<u>-d</u>+++ Horse`

A *command argument* is defined to be a command phrase that is not an option‚Äôs keyword. This is similar to an option‚Äôs argument, except that the position of this argument in the user input is important. A command argument is a command phrase that lies after the command keyword, and before any command option‚Äôs keywords.

Example of command‚Äôs arguments below. The command‚Äôs keyword is underlined.

- `+++<u>add_event</u>+++ Horse ‚Äú24/10/2019 10:00‚Äù`
- `+++<u>delete_event</u>+++ 1 2 3`

==== Argument

A command‚Äôs argument and an option‚Äôs argument are both considered an `Argument`. An argument will be parsed from a command phrase to another object. The `Argument` class is a generic class, where the type of the class defines what type of object the command phrase be parsed into.

For example, an `Argument<DateTime>` which receives ‚Äú24/10/2019 10:00‚Äù will be parsed into a `DateTime` object.


==== Variable Argument

A `VariableArgument` is a special type of argument. A variable argument will be parsed from a list of command phrases to a list of similar type objects. The `VariableArgument` class is a generic class, where the type of the class defines what types of objects the command phrases should be parsed into. A variable argument can accept zero or more command phrases to be parsed.

For example, a `VariableArgument<Integer>` which receives {1, 2, 3} will be parsed into a list of Integers. `A VariableArgument<Integer>` which receives {} will be parsed into an empty list.


==== ArgumentList

A command is said to contain a list of arguments, and it‚Äôs options are said to contain a list of arguments too. Both are considered an `ArgumentList`. An `ArgumentList` is defined to contain zero or more `Arguments`, and zero or one `VariableArguments`.

Additionally, if a variable argument is defined, it will be treated as the last argument in the `ArgumentList`. This is because a variable argument can accept zero or more command phrases, which will prevent other arguments from receiving command phrases if it is not the last argument.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<Person>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As a more OOP model, we can store a `Tag` list in `Address Book`, which `Person` can reference. This would allow `Address Book` to only require one `Tag` object per unique `Tag`, instead of each `Person` needing their own `Tag` object. An example of how such a model may look like is given below. +
 +
image:BetterModelClassDiagram.png[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in json format and read it back.

[[Design-Notification]]
=== Notification System
(Picture: Notification System)

Notifications are handled through the NotificationManager, itself found in the Logic component. There does not exist a singular Notification component. Rather, functional classes for the Notification System are have been split across the Logic and UI components, depending on their functionality.

==== Logic Classes
Logic classes are reponsible for deciding if a notification should be posted. As with other components, their functionality is accessed through the `NotificationManager` class. The `NotificationManager` class maintains a reference to a `NotificationCheckingThread` as well as a `SystemTrayCommunicator`.

The logic classes of the Notification System can be found under the `notification` package under the `Logic` component.

- The `NotificationCheckingThread` is a daemon thread that runs in parallel with the main application. It checks for new notifications to post every minute.
- The `NotificationChecker` is responsible for checking `Model` for any notifications that need to be posted.


==== UI Classes
UI classes are responsible for displaying notifications.

The UI classes of the Notification System can be found under the `systemtray` package under the `ui` component.

- The `PopupListener` class is the main channel of communication between the logic and UI classes. When a notification needs to be posted, it will relay the information from the logic to UI classes.

- The `SystemTrayCommunicator` handles posting notifications and displaying the app's icon on the System Tray.

- The `PopupNotification` class carries the information that will be posted on a popup notification.

- The `NotificationClickActionListener` is called when the user clicks on a popup notification.


[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
=== [Proposed] Undo/Redo feature
==== Proposed Implementation

The undo/redo mechanism is facilitated by `UndoRedoManager`, which contains `undoStateList` - a history of `UndoRedoStates`. Each `UndoRedoState` object contains two lists: one to store `EventSources` and the other to store `TaskSources`, together representing the state of all event and task data at that point in time. UndoRedoManager also contains a `currentStateIndex`, which keeps track of the index of the `UndoRedoState` being used presently.

A key point to take note of is that `ModelManager` contains an `eventList` (a list of `EventSources`) and a `taskList` (a list of `TaskSources`), both of which cannot be reinitialized. This is because these two lists are directly in sync with the GUI; changes to these specific list instances are reflected as changes to the GUI, but changes to other copies of `EventSource` or `TaskSource` lists will not affect the GUI. Hence, the history of `UndoRedoStates` held by `UndoRedoManager` stores deep-copies of `EventSource` and `TaskSource` lists. Should there be a need to revert back to a past or future state (if undo or redo is called), these lists will retrieve their data from the appropriate copy of `UndoRedoState` in the list of duplicates.

`UndoRedoManager` also implements the following operations:

* `UndoRedoManager#commit(UndoRedoState state)` -- Adds the new state (which contains a deep-copied version of `TaskSource` and `EventSource` lists) to the `undoStateList`
* `UndoRedoManager#undo()` -- Restore `eventList` and `taskList` in `ModelManager` to their previous versions from the appropriate duplicate in `undoStateList` via an `UndoRedoListener`
* `UndoRedoManager#redo()` -- Restore `eventList` and `taskList` in `ModelManager` to their future versions from the appropriate duplicate in `undoStateList` via an `UndoRedoListener`
* `UndoRedoManager#clearFutureHistory()`‚Äâ--‚ÄâDelete all duplicates of `UndoRedoState` that occur in `undoStateList` after the index given by the `currentStateIndex`

The `UndoCommand` and `RedoCommand` will interact directly with `UndoRedoManager` while other state-changing commands (such as adding or deleting tasks) will interact only with `ModelManager`.

There are three key *Listener* interfaces that help us achieve the desired undo-redo functionality:

* `EventListListener`
* `TaskListListener`
* `UndoRedoListener`

The `UndoRedoManager` implements the `EventListListener` interface‚Äôs method `onEventListChange(List<EventSource> events)` to ‚Äúlisten‚Äù for any changes to `ModelManager`‚Äôs `eventList`. (e.g. when an event is added or deleted) If such a change exists, it will be handled by first calling `UndoRedoManager#clearFutureHistory()`, instantiating a `UndoRedoState` with a deep-copied version of the `taskList` and the modified `eventList`, and calling `UndoRedoManager#commit(UndoRedoState state)` to commit this state. `UndoRedoManager` also implements `TaskListListener` in the same fashion, except that changes to the `taskList` are ‚Äúlistened‚Äù to rather than the `eventList`.

The `ModelManager` implements the `UndoRedoListener` interface‚Äôs method `onUndoRedo(UndoRedoState state)` to ‚Äúlisten‚Äù for any undo or redo being executed. This will be handled by updating `ModelManager`‚Äôs `eventList` and `taskList` data to match the data of the `UndoRedoState` with index `currentStateIndex` in `undoStateList`.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

Step 1. The user runs the program for the first time. The `UndoRedoManager` will be initialized with the initial `undoStateList`. An `UndoRedoState` will be added to `undoStateList` and the `currentStateIndex` will point to that single `undoRedoState` in the list.

image::UndoRedoState0.png[]

Step 2. The user executes `add_event ‚ÄúSuntec City Computer Fair‚Äù --at ‚Äú17/11/2019 12:00‚Äù`. The event will be added to `ModelManager`‚Äôs `eventList`. Then, `UndoRedoManager#onEventListChange(List<EventSource> events)` will be called (as there has been a change to the `eventList`), clearing all future states beyond the `currentStateIndex` as they are no longer useful. In this particular case, there are no future states to be cleared. Then, the modified `eventList` and `taskList` will be deep-copied and a new `UndoRedoState` containing the deep-copies will be added to `undoStateList`. The `currentStateIndex` is incremented by one to contain the index of the newly inserted undo redo state.

image::UndoRedoState1.png[]

[NOTE]
If a command fails its execution, it will not result in any change to `ModelManager#eventList` or `ModelManager#taskList`. Hence, there is no change to trigger the listener methods and thus no `UndoRedoState` will be saved to `undoStateList`.

Step 3. Suppose the user decides that adding the task was a mistake. He/she then executes the undo command to rectify the error. The undo command will decrement the `currentStateIndex` by one to contain the index of the previous undo redo state, thereafter triggering the `UndoRedoListener#onUndoRedo` method. This method updates `ModelManager`‚Äôs `eventList` and `taskList` data to match the data of the `UndoRedoState` with index `currentStateIndex` in `undoStateList`.

image::UndoRedoState2.png[]

[NOTE]
If the `currentStateIndex` is 0, pointing to the initial undo redo state, then there are no previous undo redo states to restore. The undo command uses `UndoRedoManager#canUndo()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

The following sequence diagram shows how the undo operation works:

image::UndoSequenceDiagram.png[width=100%]

NOTE: The lifeline for `UndoCommand` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

The redo command does the opposite ‚Äî it calls `UndoRedoManager#redo()`, which increments the `currentStateIndex` by one to contain the index of the previously undone state. The `UndoRedoListener` then causes `ModelManager#eventList` and `ModelManager#taskList` to reset their data to this state‚Äôs list data.

[NOTE]
If the `currentStateIndex` is at index `undoStateList.size() - 1`, pointing to the latest undo redo state, then there are no undone undo redo states to restore. The `redo` command uses `UndoRedoManager#canRedo()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

Step 4. The user decides to execute the command `log`. Non-state-changing commands such as `log` do not manipulate task and event data. Since no changes to `taskList` or `eventList` have been made, the listener methods will not be triggered and no `UndoRedoState` will be saved to `undoStateList`. Thus, the `undoStateList` remains unchanged.

image::UndoRedoState3.png[]

Step 5. The user executes `delete_event 1`, removing the event from `ModelManager`‚Äôs `eventList`. `UndoRedoManager#onEventListChange(List<EventSource> events)` will be called (as there has been a change to the `eventList`), purging all future states beyond the `currentStateIndex` as they are no longer useful. Then, the modified `eventList` and `taskList` will be deep-copied and a new `UndoRedoState` containing the deep-copies will be added to `undoStateList`. The `currentStateIndex` is incremented by one to contain the index of the newly inserted undo redo state.

image::UndoRedoState4.png[]

The following activity diagram summarizes what happens when a user executes a new command:

image::CommitActivityDiagram.png[]

==== Design Considerations

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves `EventSource` and `TaskSource` data every time a change has been made.
** Pros: Easy to understand and implement.
** Cons: Performance issues may arise due to the relatively larger memory usage required.
* **Alternative 2:** Individual command knows how to undo/redo by itself; inverse functions have to be implemented (if I undo the deletion of a person, it would be equivalent to adding him back to the list)
** Pros: Uses less memory as we only need to keep track of what commands have been executed and their parameters, as opposed to storing all task and event data between every change.
** Cons: Every command will have to be implemented twice, since their inverse operations will all be different. This is compounded by the fact that we have to ensure the correctness of every inverse operation individually as well.
// end::undoredo[]

// tag::dataencryption[]
=== [Proposed] Data Encryption

_{Explain here how the data encryption feature will be implemented}_

// end::dataencryption[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Design-Ics]]
=== Ics Component

*API* : link:{repoURL}/src/main/java/seedu/address/ics/IcsParser.java[`IcsParser.java`]

The ICS component is made up of two parts: ICS file importer, and ICS file exporter.

The file importer makes use of a custom parser that converts files with the `.ics` file extension
to `EventSource` objects in Horo.

The file exporter takes the `EventSource` objects stored in the `Model` singleton object and
generates ICS String representations of them. Check out the
link:https://en.wikipedia.org/wiki/ICalendar[ICalendar Wiki Page] for more information on the specifications.


* Can export Horo's save data as a file
The `ICS` Component,with a `.ics` extension.
* Can import other Horo's save data from a `.ics` file.


== Implementation

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* is a student
* has a need to manage their Events and Tasks for visualization.
* requires reminders for their Events and Tasks.
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: manage Reminders as well as viewing Events and Tasks much faster than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |add an Event or Task |keep track of an Event or Task that I have in the future

|`* * *` |user |delete an Event or Task |remove the Event or Task I no longer need.

|`* * *` |user |find an Event or Task by name |locate the details of the Event or Task without having to go through the entire list

|`* * *` |user |find an Event or Task by tags|remember the details of the Event or Task that I forget about

|`* * *` |user|undo and redo commands |undo any commands which wrongly inputted

|`* * *` |user|edit my Events and Tasks |change the details of the event, be it location, date or time

|`* * *` |user that works on multiple computer |port my data between computers |keep track on all my computers.

|`* * *` |student |have constant reminders to track the deadline of my assignments |not forget to complete and submit them

|`* * *` |student |keep track of how long it takes for me to complete a task |gauge how long I will need to take for future similar tasks

|`* * *` |student with weekly assignments and lectures |have my reminders to be recurring | be reminded without having to input the information in again

|`* * *` |busy student |have a convenient way to visually see my assignments and projects |complete them in the right priority

|`* * *` |busy user |be informed if any different events clash with each other |understand which event to prioritize or reschedule

|`* *` |user |add a contacts | add them into Events to remind myself who I am meeting up with

|`* *` |user |archive my completed Tasks | remind myself if I complete a task but forgot about it

|`* *` |user |create custom commands that contain the execution of multiple sub-commands |quickly input in a command without the need to edit it

|`* *` |student |visualize my timetable |plan for when it is time to take a break from studying

|`* *` |student |find a time for my project teammates to meet up |schedule a meeting without clashing together with other events

|`*` |user |import contacts in vCard format| integrate them with my events

|`*` |user |export contacts in vCard format | integrate them with my other computers

|`*` |student |keep track of sub-tasks in a main task | know my current progress in a report

|=======================================================================

_{More to be added}_

[appendix]
== Use Cases

(For all use cases below, the *System* is the `Horo` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case 1: Add a Task

*MSS*

1.  User requests to add a Task
2.  Horo replies that the Task has been added
+
Use case ends.

*Extensions*

* 1a. The user adds additional sub-commands to the Task command
+
Use case ends.


* 2a. The given add Task command is of the wrong format.
+
[none]
** 2a1. Horo displays an error message.
+
Use case resumes at step 1.

[discrete]
=== Use case 2: Delete a Task

*MSS*

1.  User requests to delete a specific Task from the already displayed list
2.  Horo deletes the Task
+
Use case ends.

*Extensions*

[none]
* 2a. The given delete Task command is of the wrong format.
+
[none]
** 2a1. Horo displays an error message.
+
Use case resumes at step 1.

[discrete]
=== Use case 3: Find a Task by name

*MSS*

1.  User requests to find a Task
2.  Horo displays the list of Task with the keywords found in its name
+
Use case ends.

*Extensions*

[none]
* 2a. The given find Task command is of the wrong format.
+
[none]
** 2a1. Horo displays an error message.
+
Use case resumes at step 1.

[discrete]
=== Use case 4: Undo and Redo commands

*MSS*

1.  User requests to add an Task
2.  Horo replies that the Task has been added
3.  User requests to undo the command
4.  Horo replies that the previous command has been undone
+
Use case ends.

*Extensions*

* 1a. The user adds additional sub-commands to the Task command
+
Use case ends.

* 2a. The given add Task command is of the wrong format.
+
[none]
** 2a1. Horo displays an error message.
Use case resumes at step 1

* 4a. User decides the to Redo the added Task
+
[none]
** 3a1. Horo replies that the added Task has been redone
+
Use case ends

[discrete]
=== Use case 5: Edit a Task

*MSS*

1.  User requests to add a Task
2.  Horo replies that the Task has been added
3.  User request to edit a Task with the sub-commands
4.  Horo replies that the Task has been edited
+
Use case ends.

*Extensions*

* 1a. The user adds additional sub-commands to the Task command
+
Use case ends.

* 2a. The given add Task command is of the wrong format.
+
[none]
** 2a1. Horo displays an error message.
+
Use case resumes at step 1.

* 4a. The given edit Task command is of the wrong format.
+
[none]
** 4a1. Horo displays an error message.
+
Use case resumes at step 3.
+
_{More to be added}_

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 Events and Tasks without a noticeable sluggishness in performance for typical usage.
.  Should function on both `32-bit environment` and `64-bit environment`
.  Should work without any internet required.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.


_{More to be added}_

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[event]] Event::
A thing that happens or takes place during a certain period of time, or of a general time.

[[task]] Task::
A piece of work that is to be completed or taken note of.

[appendix]
== Product Survey

*reminder-bot on Discord*

Author: JellyWX

Pros:

* A reminder bot on a popular voice and text chat application
* Capable of parsing english language as compared to CLI styled commands

Cons:

* Lack of visualization of the Events and Tasks
* Parsing english language makes it slower to type with a longer requirement as compared to CLI styled commands

*Google Calendar*

Company: Google

Pros:

* A Calendar application that is capable of storing Events and Tasks as well.
* Mostly uses GUI for interaction with user instead of having CLI, favouring to the common crowd.

Cons:

* Mostly uses GUI for interaction with user instead of having CLI, which does not favour those who prefers CLI.
* It requires an account to be usable.
* The desktop version requires a browser, which in turn requires Internet and hence not offline.

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_



